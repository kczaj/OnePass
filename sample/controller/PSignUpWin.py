#######################################################
# 
# PSignUpWin.py
# Python implementation of the Class PSignUpWin
# Generated by Enterprise Architect
# Created on:      04-kwi-2020 11:43:15
# Original author: KUBA
# 
#######################################################

from sample.controller.PController import PController
from sample.model.MProfileMaker import MProfileMaker
import string
import os

# remember about MainWinAfter
from sample.view.VEncrypWin import VEncrypWin
from sample.view.VGenerateWinAfter import VGenerateWinAfter
from sample.view.VMainWinAfter import VMainWinAfter
from sample.view.VNoteListWin import VNoteListWin
from sample.view.VPasswordsListWin import VPasswordsListWin


class PSignUpWin(PController):
    NOT_ALL_GAPS_FILLED_ERROR = 'Wypełnij wszystkie pola'
    NAME_ERROR = 'Podane imię jest niepoprawne'
    SURNAME_ERROR = 'Podane nazwisko jest niepoprawne'
    EMAIL_ERROR = 'Podany mail jest niepoprawny'
    LOGIN_ERROR = 'Podany login jest niepoprawny'
    PASSWORD_ERROR = 'Podane hasło nie spełnia wymogów'
    LOGIN_WRONG_NAME_ERROR = "Podany login istnieje już w bazie"

    def __init__(self, sign_up_win, main_window, _loader, main_win_before, generate_win, hasher):
        super().__init__(main_window, main_win_before)
        self._loader = _loader
        self._profile_maker = MProfileMaker()
        self._sign_up_win = sign_up_win
        self._generate_win = generate_win
        self._hasher = hasher

    def sign_up_button_handle(self, name, surname, email, login, password):
        status = self.__validate_data(name, surname, email, login, password)
        if status == '1':
            profile = self._profile_maker.make_profile(name, surname, email, login, password)
            logins = self._loader.get_logins()
            logins[login] = self._hasher.hash(password)
            os.mkdir('data/' + login)
            os.mkdir('data/' + login + '/note')
            os.mkdir('data/' + login + '/encrypted')
            main_win_after = VMainWinAfter(self.main_window, self.main_win_before, self._loader, self._hasher)
            win_list = [main_win_after, VPasswordsListWin(self.main_window),
                        VNoteListWin(self.main_window), VEncrypWin(self.main_window),
                        VGenerateWinAfter(self.main_window, main_win_after)]
            for i in range(len(win_list)):
                win_list[i].set_window_list(win_list)
                win_list[i].set_profile(profile)
            win_list[0].set_window_list_in_subwindow()
            self.change_window(win_list[0])
            return '1'
        else:
            return status

    def __validate_data(self, name, surname, email, login, password):
        special_symols = '!@#$%^&*()_-+={[}]\:;<,>.?/'
        digits = string.digits
        upper = string.ascii_uppercase
        lower = string.ascii_lowercase
        status = 0
        if name != '' and surname != '' and email != '' and login != '' and password != '':
            for c in special_symols + digits:
                if c in name:
                    return self.NAME_ERROR
                if c in surname:
                    return self.SURNAME_ERROR
            for c in special_symols:
                if c in login:
                    return self.LOGIN_ERROR
            logins = self._loader.get_logins()
            if '@' not in email:
                return self.EMAIL_ERROR
            if login in logins:
                return self.LOGIN_WRONG_NAME_ERROR
            if len(password) > 8:
                for c in password:
                    if c in upper:
                        status = status + 1
                        break
                for c in password:
                    if c in lower:
                        status = status + 1
                        break
                for c in password:
                    if c in digits:
                        status = status + 1
                if status != 3:
                    return self.PASSWORD_ERROR
            else:
                return self.PASSWORD_ERROR
            return '1'
        else:
            return self.NOT_ALL_GAPS_FILLED_ERROR
